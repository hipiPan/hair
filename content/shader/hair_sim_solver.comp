#version 450
#extension GL_GOOGLE_include_directive : enable

#include "hair_shader_defs.glsl"

layout(std430, binding = 0) restrict writeonly buffer PositionDataBufferBlock
{
    vec3 data[];
} position_data_buffer;

layout(std430, binding = 1) restrict writeonly buffer PositionPreDataBufferBlock
{
    vec3 data[];
} position_pre_data_buffer;

layout(std430, binding = 2) restrict writeonly buffer PositionPrePreDataBufferBlock
{
    vec3 data[];
} position_pre_pre_data_buffer;

layout(std430, binding = 3) restrict writeonly buffer VelocityDataBufferBlock
{
    vec4 data[];
} velocity_data_buffer;

layout(std430, binding = 4) restrict writeonly buffer VelocityPreDataBufferBlock
{
    vec4 data[];
} velocity_pre_data_buffer;

layout(std430, binding = 5) restrict readonly buffer RootPositionDataBufferBlock
{
    vec3 data[];
} root_position_data_buffer;

layout(std140, binding = 6) uniform SolverDataBuffer
{
    vec4 world_gravity;
    float dt;
} solver_data_buffer;

vec3 integrate_position_second_order(float dt, vec3 x0, vec3 x0_minus1, vec3 v0, vec3 v0_minus1, vec3 a0)
{
    // Second order prediction
    // http://www.cs.ubc.ca/~rbridson/docs/english-siggraph08-cloth.pdf
    return (
        (4.0 / 3.0) * x0 -
        (1.0 / 3.0) * x0_minus1 +
        (8.0 / 9.0) * dt * v0 -
        (2.0 / 9.0) * dt * v0_minus1 +
        (4.0 / 9.0) * dt * dt * a0
    );
}

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
void main()
{
    if (gl_GlobalInvocationID.x >= constant.strand_count)
        return;

    uint strand_index = gl_GlobalInvocationID.x;
    uint strand_particle_begin = strand_index * constant.strand_particle_count;
    uint strand_particle_end = strand_particle_begin + constant.strand_particle_count;

    // Update positions
    position_data_buffer.data[strand_particle_begin] = root_position_data_buffer.data[strand_index];
    for (uint i = strand_particle_begin + constant.strand_particle_stride; i != strand_particle_end; i += constant.strand_particle_stride)
    {
        vec3 x0 = position_pre_data_buffer.data[i];
        vec3 v0 = velocity_pre_data_buffer.data[i];
        vec3 x0_minus1 = position_pre_pre_data_buffer.data[i];
        vec3 v0_minus1 = velocity_data_buffer.data[i];
        vec3 a = solver_data_buffer.world_gravity.xyz;
        position_data_buffer.data[i] = integrate_position_second_order(solver_data_buffer.dt, x0, x0_minus1, v0, v0_minus1, a0);
    }

    // Solve constraints(Gauss-Seidel iteration)
    uint iterations = 2;
    for (uint iteration = 0; iteration != iterations; iteration++)
    {
        // Distance constraint
        {

        }
    }
}